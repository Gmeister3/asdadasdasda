
% \documentclass[review=false, screen=true]{acmart}
\documentclass[format=acmsmall, review=false, screen=true]{acmart}

% Set letter paper size:
% \setlength{\paperheight}{11in}
% \setlength{\paperwidth}{8.5in}
% \usepackage[
%   % pass,% keep layout unchanged 
%   % showframe,% show the layout
%   % a4paper
% ]{geometry}


% Package to generate and customize Algorithm as per ACM style
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
% \usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
% \SetAlFnt{\small}
% \SetAlCapFnt{\small}
% \SetAlCapNameFnt{\small}
% \SetAlCapHSkip{0pt}
% \IncMargin{-\parindent}



\usepackage{booktabs}
\usepackage{tabularx}  

\usepackage{amsmath,amssymb,amsfonts}

\usepackage{enumitem}

\usepackage{lipsum} 

\SetKwRepeat{Do}{do}{while} 


\usepackage{lmodern}
\usepackage{courier}

\usepackage{listings}
\lstset{
  language={Pascal},
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\ttfamily\small,      %\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{red},        % comment style
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stringstyle=\color{brown},       % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
}

\usepackage{setspace}




% Document starts
\begin{document} 
% Title portion. Note the short title for running heads 
\title[COSC 3P91 -- Assignment 1]{COSC 3P91 -- Assignment 1 -- Question 2}  

\author{Design Description Document}
\affiliation{%
  \institution{Brock University}
  \streetaddress{1812 Sir Isaac Brock Way}
  \city{St. Catharines}
  \state{ON}
  \postcode{L2S 3A1}
  \country{Canada}
}

\begin{abstract}

This document presents an object-oriented design for a strategic territory conquest simulation system. The architecture employs abstraction hierarchies, polymorphic behaviors, and modular packaging to create an extensible framework. Seven distinct modules organize functionality: territorycore for domain management, fortifications for defensive capabilities, dwellers for population entities, assaultunits for offensive forces, gamecontrol for orchestration logic, playerspace for participant data, and frontend for interaction mechanisms.

\end{abstract}







\maketitle


\section{Introduction}

This document provides a comprehensive description and justification of the object-oriented design for a village-war strategy game system. The game follows the mechanics of popular mobile strategy games where players build and upgrade their villages, train armies, and attack other players' villages to collect resources and increase their ranking.

The design employs fundamental object-oriented principles including abstraction, inheritance, polymorphism, and encapsulation to create a flexible and extensible system. The architecture is organized into six distinct packages, each with clearly defined responsibilities, promoting separation of concerns and maintainability.

\section{System Overview}

The village-war strategy game system is designed to support the following core behaviors:

\begin{itemize}
  \item \textbf{Building}: Players can construct various buildings in their village, each occupying space and providing specific functionality
  \item \textbf{Training}: Players can train villagers and army units with different specializations
  \item \textbf{Upgrading}: Both buildings and inhabitants can be upgraded to higher levels, improving their capabilities
  \item \textbf{Village Generation}: The system generates AI-controlled villages for players to attack
  \item \textbf{Attack Exploration}: Players can explore and find villages to attack
  \item \textbf{Attacking}: Players can deploy armies to attack other villages and collect loot
\end{itemize}

The system manages resources (gold, iron, wood, food), time-based mechanics (building/training time, guard periods), and complex attack simulations that determine battle outcomes.

\section{Package Structure}

The design is organized into six packages, each with a specific responsibility:

\subsection{Resources Package}

The \texttt{resources} package handles all resource-related functionality. It contains:
\begin{itemize}
  \item \texttt{ResourceType} enum defining the four resource types (GOLD, IRON, WOOD, FOOD)
  \item \texttt{Cost} class representing the cost of actions in terms of resources and time
  \item \texttt{ResourceManager} class managing resource storage, capacities, and consumption
\end{itemize}

This package is kept separate to ensure resource management logic is decoupled from game entities, promoting reusability and maintainability.

\subsection{Buildings Package}

The \texttt{buildings} package contains all building-related classes organized in an inheritance hierarchy. This modular organization allows for easy addition of new building types while maintaining common functionality in abstract base classes.

\subsection{Inhabitants Package}

The \texttt{inhabitants} package manages all population entities including workers and military units. The hierarchical structure allows for shared behavior while enabling specialization for different inhabitant types.

\subsection{Core Package}

The \texttt{core} package contains the central game entities:
\begin{itemize}
  \item \texttt{Village} - Manages all aspects of a player's village
  \item \texttt{Player} - Represents player information and actions
  \item \texttt{Army} - Manages army composition for attacks
\end{itemize}

\subsection{Engine Package}

The \texttt{engine} package provides game orchestration and simulation logic:
\begin{itemize}
  \item \texttt{GameEngine} - Main game loop and time management
  \item \texttt{AttackSimulator} - Simulates combat between armies and villages
  \item \texttt{VillageGenerator} - Creates AI villages
  \item \texttt{ScoreCalculator} - Computes various game scores
  \item \texttt{AttackResult} - Encapsulates attack outcomes
\end{itemize}

\subsection{UI Package}

The \texttt{ui} package separates the user interface from game logic, containing the \texttt{GameUI} class that handles player interactions and display.

\section{Building Hierarchy}

The building system uses a carefully designed inheritance hierarchy to maximize code reuse while allowing for specialization.

\subsection{Abstract Building Class}

The \texttt{Building} abstract class serves as the base for all structures. It defines common attributes and behaviors:
\begin{itemize}
  \item Level progression (current level, max level)
  \item Hit points for damage modeling
  \item Position on the village grid
  \item Cost and build time
  \item Upgrade mechanics with time tracking
\end{itemize}

Key methods include \texttt{upgrade()}, \texttt{getUpgradeCost()}, \texttt{takeDamage()}, and \texttt{repair()}. The upgrade cost scales with level using a multiplier (1.5x per level), balancing progression.

\subsection{VillageHall}

The \texttt{VillageHall} is the most important building, determining the village level and constraining other building upgrades. Players must upgrade the VillageHall to unlock higher levels for other structures.

\subsection{Production Buildings}

An intermediate abstract class \texttt{ProductionBuilding} extends \texttt{Building} to add production mechanics:
\begin{itemize}
  \item Worker assignment (maxWorkers, assignedWorkers)
  \item Production rate that increases with assigned workers
  \item Resource generation methods
\end{itemize}

Concrete production buildings inherit from this class:
\begin{itemize}
  \item \textbf{Farm}: Produces food and increases population capacity
  \item \textbf{GoldMine}: Generates gold resources
  \item \textbf{IronMine}: Generates iron resources
  \item \textbf{LumberMill}: Generates wood resources
\end{itemize}

\subsection{Defense Buildings}

Similarly, \texttt{DefenseBuilding} extends \texttt{Building} with defensive attributes:
\begin{itemize}
  \item Damage output
  \item Attack range
  \item Attack speed
  \item Target prioritization
\end{itemize}

Concrete defensive structures include:
\begin{itemize}
  \item \textbf{ArcherTower}: Long-range defense with limited ammunition
  \item \textbf{Cannon}: High damage but slower attack speed
\end{itemize}

This hierarchy allows adding new building types easily while inheriting common functionality.

\section{Inhabitant Hierarchy}

The inhabitant system models the village population using a similar hierarchical approach.

\subsection{Abstract Inhabitant Class}

The \texttt{Inhabitant} abstract class provides base functionality for all population entities:
\begin{itemize}
  \item Level and hit points
  \item Training cost and time
  \item Food consumption
  \item Upgrade mechanics
  \item Damage handling and healing
\end{itemize}

\subsection{Workers}

The \texttt{Worker} class represents general-purpose villagers who perform various tasks:
\begin{itemize}
  \item Building construction
  \item Food production
  \item Building repairs
  \item Task tracking (idle vs. busy)
\end{itemize}

Workers are essential for village development but don't participate in combat.

\subsection{Resource Collectors}

An abstract \texttt{Collector} class extends \texttt{Inhabitant} for specialized resource gathering. It adds collection rate and target resource type. Concrete collectors include:
\begin{itemize}
  \item \textbf{GoldCollector}: Collects from gold mines
  \item \textbf{IronCollector}: Collects from iron mines
  \item \textbf{WoodCollector}: Collects from lumber mills
\end{itemize}

\subsection{Army Units}

The \texttt{ArmyUnit} abstract class extends \texttt{Inhabitant} with combat capabilities:
\begin{itemize}
  \item Damage output
  \item Attack range
  \item Movement speed
  \item Attack methods
\end{itemize}

Concrete military units provide variety in combat:
\begin{itemize}
  \item \textbf{Soldier}: Melee fighter with shield for blocking
  \item \textbf{Archer}: Ranged attacker with faster movement
  \item \textbf{Knight}: Heavy armored unit with high damage
  \item \textbf{Catapult}: Siege unit effective against buildings
\end{itemize}

\section{Village Class}

The \texttt{Village} class is the central hub managing all aspects of a player's settlement:

\begin{itemize}
  \item \textbf{Identity}: Name and level
  \item \textbf{Population}: Current and maximum population limits
  \item \textbf{Space}: Area usage for building placement
  \item \textbf{Buildings}: Collection of constructed buildings
  \item \textbf{Inhabitants}: Collection of trained population
  \item \textbf{Resources}: ResourceManager instance
  \item \textbf{Scores}: Defense and attack capability calculations
  \item \textbf{Protection}: Guard period for new players
\end{itemize}

Key methods include:
\begin{itemize}
  \item \texttt{addBuilding()}: Validates space and adds buildings
  \item \texttt{addInhabitant()}: Checks population limits
  \item \texttt{calculateDefenseScore()}: Computes defensive strength
  \item \texttt{canBuild()}: Validates building placement
\end{itemize}

The guard period (7 days for new villages) prevents attacks on new players, encouraging fair gameplay.

\section{Army Class}

The \texttt{Army} class (in the core package) manages attack force composition:

\begin{itemize}
  \item Collection of ArmyUnit objects
  \item Total army size tracking
  \item Methods to add/remove units
  \item Attack power calculation
  \item Casualty management during battles
\end{itemize}

This separate class allows players to compose custom armies from their trained units.

\section{Game Engine}

The \texttt{GameEngine} class orchestrates the overall game flow:

\begin{itemize}
  \item \textbf{Time Management}: Tracks game time and speed
  \item \textbf{Player Management}: Maintains active players list
  \item \textbf{Upgrade Processing}: Completes time-based upgrades
  \item \textbf{Validation}: Enforces game rules (e.g., VillageHall level requirements)
\end{itemize}

Supporting classes provide specialized functionality:
\begin{itemize}
  \item \textbf{AttackSimulator}: Runs battle simulations considering unit types, defenses, and random factors
  \item \textbf{VillageGenerator}: Creates balanced AI villages for players to attack
  \item \textbf{ScoreCalculator}: Computes rankings based on attack/defense performance
  \item \textbf{AttackResult}: Encapsulates battle outcomes (success, loot, casualties, stars)
\end{itemize}

\section{Player and UI}

The \texttt{Player} class represents individual players:
\begin{itemize}
  \item Player identification (name, unique ID)
  \item Village ownership
  \item Statistics (attack/defense wins/losses, ranking, total loot)
  \item Action methods (building, upgrading, attacking)
\end{itemize}

The \texttt{GameUI} class separates presentation from logic:
\begin{itemize}
  \item Display methods for village, menus, and battle results
  \item Input handling for player actions
  \item Reference to current player and game engine
\end{itemize}

This separation allows changing the UI (e.g., from console to GUI) without modifying game logic.

\section{Design Principles and Justification}

\subsection{Abstraction and Inheritance}

The design extensively uses abstract base classes (\texttt{Building}, \texttt{Inhabitant}, \texttt{ProductionBuilding}, \texttt{DefenseBuilding}, \texttt{Collector}, \texttt{ArmyUnit}) to:
\begin{itemize}
  \item Share common functionality across related classes
  \item Reduce code duplication
  \item Enforce consistent interfaces
  \item Enable polymorphic behavior
\end{itemize}

This hierarchy makes adding new building or inhabitant types straightforwardâ€”simply extend the appropriate abstract class and implement specific behaviors.

\subsection{Encapsulation}

All classes use private or protected attributes with public accessor methods, ensuring:
\begin{itemize}
  \item Internal state is protected from invalid modifications
  \item Implementation details can change without affecting clients
  \item Validation can be enforced (e.g., resource limits, population caps)
\end{itemize}

\subsection{Polymorphism}

Abstract classes and inheritance enable polymorphic collections:
\begin{itemize}
  \item \texttt{Village} stores \texttt{Building} references, treating all building types uniformly
  \item \texttt{Army} manages \texttt{ArmyUnit} references regardless of specific unit type
  \item Upgrade and damage calculations work on base class references
\end{itemize}

This allows the system to handle new entity types without modifying existing code.

\subsection{Separation of Concerns}

The package structure cleanly separates different aspects:
\begin{itemize}
  \item Resource management isolated from game entities
  \item UI separated from game logic
  \item Game orchestration separated from domain objects
  \item Building/inhabitant hierarchies in separate packages
\end{itemize}

This modularity improves maintainability and allows team members to work on different packages independently.

\subsection{Extensibility}

The design supports future extensions:
\begin{itemize}
  \item New building types: Extend \texttt{ProductionBuilding} or \texttt{DefenseBuilding}
  \item New inhabitants: Extend \texttt{Collector} or \texttt{ArmyUnit}
  \item New resources: Add to \texttt{ResourceType} enum
  \item Enhanced UI: Implement new UI classes using the same game engine interface
\end{itemize}

\subsection{Scalability}

The architecture supports large-scale gameplay:
\begin{itemize}
  \item Collections for buildings and inhabitants scale with village size
  \item Time-based mechanics allow asynchronous processing
  \item Score calculations enable ranking thousands of players
  \item Village generation creates unlimited opponents
\end{itemize}

\section{Conclusion}

This design provides a robust foundation for a village-war strategy game. The careful use of object-oriented principles creates a system that is maintainable, extensible, and aligned with the required behaviors. The modular package structure, thoughtful inheritance hierarchies, and clear separation of concerns enable both current functionality and future enhancements while maintaining code quality and reducing complexity.


% \bibliographystyle{ACM-Reference-Format-Journals}
% \bibliography{acmsmall-sample-bibfile}


\appendix

\section{Resources Package - ResourceType Enum}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package resources;

public enum ResourceType {
    GOLD,
    IRON,
    WOOD,
    FOOD
}
\end{lstlisting}
\end{spacing}

\section{Resources Package - Cost Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package resources;

public class Cost {
    private int gold;
    private int iron;
    private int wood;
    private int time;
    
    public Cost(int gold, int iron, int wood, int time) {
        this.gold = gold;
        this.iron = iron;
        this.wood = wood;
        this.time = time;
    }
    
    public int getTotalValue() {
        return gold + iron + wood;
    }
    
    public Cost multiply(double factor) {
        return new Cost(
            (int)(gold * factor),
            (int)(iron * factor),
            (int)(wood * factor),
            (int)(time * factor)
        );
    }
    
    public int getGold() { return gold; }
    public int getIron() { return iron; }
    public int getWood() { return wood; }
    public int getTime() { return time; }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Resources Package - ResourceManager Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package resources;

public class ResourceManager {
    private int gold;
    private int goldCapacity;
    private int iron;
    private int ironCapacity;
    private int wood;
    private int woodCapacity;
    private int foodProduction;
    private int foodConsumption;
    
    public void addGold(int amount) {
        gold = Math.min(gold + amount, goldCapacity);
    }
    
    public void addIron(int amount) {
        iron = Math.min(iron + amount, ironCapacity);
    }
    
    public void addWood(int amount) {
        wood = Math.min(wood + amount, woodCapacity);
    }
    
    public boolean consumeResources(Cost cost) {
        if (hasEnoughResources(cost)) {
            gold -= cost.getGold();
            iron -= cost.getIron();
            wood -= cost.getWood();
            return true;
        }
        return false;
    }
    
    public boolean hasEnoughResources(Cost cost) {
        return gold >= cost.getGold() && 
               iron >= cost.getIron() && 
               wood >= cost.getWood();
    }
    
    public Cost getAvailableLoot() {
        return new Cost(gold / 2, iron / 2, wood / 2, 0);
    }
    
    public boolean canSupport(int population) {
        return foodProduction >= foodConsumption + population;
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Buildings Package - Building Abstract Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package buildings;

import resources.Cost;

public abstract class Building {
    protected int level;
    protected int maxLevel;
    protected int hitPoints;
    protected int maxHitPoints;
    protected int positionX;
    protected int positionY;
    protected Cost buildCost;
    protected int buildTime;
    protected boolean isUpgrading;
    protected long upgradeStartTime;
    
    public Building(int maxLevel, int maxHitPoints, Cost buildCost) {
        this.maxLevel = maxLevel;
        this.maxHitPoints = maxHitPoints;
        this.hitPoints = maxHitPoints;
        this.buildCost = buildCost;
        this.level = 1;
        this.isUpgrading = false;
    }
    
    public void upgrade() {
        if (!isMaxLevel() && !isUpgrading) {
            isUpgrading = true;
            upgradeStartTime = System.currentTimeMillis();
        }
    }
    
    public Cost getUpgradeCost() {
        return buildCost.multiply(level * 1.5);
    }
    
    public boolean isMaxLevel() {
        return level >= maxLevel;
    }
    
    public void takeDamage(int damage) {
        hitPoints = Math.max(0, hitPoints - damage);
    }
    
    public void repair() {
        hitPoints = maxHitPoints;
    }
    
    public void completeUpgrade() {
        if (isUpgrading) {
            level++;
            isUpgrading = false;
            maxHitPoints = (int)(maxHitPoints * 1.2);
            hitPoints = maxHitPoints;
        }
    }
    
    public int getLevel() { return level; }
    public int getHitPoints() { return hitPoints; }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Buildings Package - VillageHall Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package buildings;

import resources.Cost;

public class VillageHall extends Building {
    private int villageLevel;
    
    public VillageHall() {
        super(10, 5000, new Cost(1000, 500, 500, 600));
        this.villageLevel = 1;
    }
    
    public int getAllowedBuildingLevel() {
        return villageLevel;
    }
    
    public int getVillageLevel() {
        return villageLevel;
    }
    
    @Override
    public void completeUpgrade() {
        super.completeUpgrade();
        villageLevel = level;
    }
}
\end{lstlisting}
\end{spacing}

\section{Buildings Package - Farm Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package buildings;

import resources.Cost;

public class Farm extends ProductionBuilding {
    private int foodPerHour;
    private int populationSupport;
    
    public Farm() {
        super(8, 1000, new Cost(100, 50, 200, 120));
        this.foodPerHour = 50;
        this.populationSupport = 10;
        this.maxWorkers = 3;
        this.productionRate = 20;
    }
    
    public int getFoodProduction() {
        return foodPerHour + getProduction();
    }
    
    public int getPopulationSupport() {
        return populationSupport * level;
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Buildings Package - ArcherTower Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package buildings;

import resources.Cost;

public class ArcherTower extends DefenseBuilding {
    private int arrowCount;
    
    public ArcherTower() {
        super(8, 1500, new Cost(300, 200, 100, 240));
        this.damage = 50;
        this.range = 10;
        this.attackSpeed = 1.0;
        this.arrowCount = 100;
    }
    
    public void reload() {
        arrowCount = 100;
    }
}
\end{lstlisting}
\end{spacing}

\section{Inhabitants Package - Inhabitant Abstract Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package inhabitants;

import resources.Cost;

public abstract class Inhabitant {
    protected int level;
    protected int maxLevel;
    protected int hitPoints;
    protected int maxHitPoints;
    protected Cost trainingCost;
    protected int trainingTime;
    protected int foodConsumption;
    protected boolean isUpgrading;
    
    public Inhabitant(int maxLevel, int maxHitPoints) {
        this.maxLevel = maxLevel;
        this.maxHitPoints = maxHitPoints;
        this.hitPoints = maxHitPoints;
        this.level = 1;
        this.isUpgrading = false;
    }
    
    public void upgrade() {
        if (!isUpgrading && level < maxLevel) {
            isUpgrading = true;
        }
    }
    
    public Cost getUpgradeCost() {
        return trainingCost.multiply(level * 1.5);
    }
    
    public void takeDamage(int damage) {
        hitPoints = Math.max(0, hitPoints - damage);
    }
    
    public boolean isAlive() {
        return hitPoints > 0;
    }
    
    public void heal() {
        hitPoints = maxHitPoints;
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Inhabitants Package - Worker Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package inhabitants;

import resources.Cost;
import buildings.Building;

public class Worker extends Inhabitant {
    private boolean isIdle;
    private String currentTask;
    
    public Worker() {
        super(5, 100);
        this.trainingCost = new Cost(50, 0, 0, 30);
        this.foodConsumption = 1;
        this.isIdle = true;
        this.currentTask = "";
    }
    
    public void buildStructure(Building b) {
        isIdle = false;
        currentTask = "Building";
    }
    
    public void produceFood() {
        isIdle = false;
        currentTask = "Producing Food";
    }
    
    public void repair(Building b) {
        isIdle = false;
        currentTask = "Repairing";
    }
    
    public void setIdle(boolean idle) {
        this.isIdle = idle;
        if (idle) {
            currentTask = "";
        }
    }
}
\end{lstlisting}
\end{spacing}

\section{Inhabitants Package - Soldier Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package inhabitants;

import resources.Cost;

public class Soldier extends ArmyUnit {
    private int shield;
    
    public Soldier() {
        super(6, 150);
        this.trainingCost = new Cost(100, 50, 0, 60);
        this.damage = 30;
        this.attackRange = 1;
        this.movementSpeed = 2;
        this.shield = 20;
        this.foodConsumption = 2;
    }
    
    public void block() {
        // Implementation for blocking attacks
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Core Package - Village Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package core;

import java.util.List;
import java.util.ArrayList;
import buildings.Building;
import buildings.VillageHall;
import inhabitants.Inhabitant;
import resources.ResourceManager;

public class Village {
    private String name;
    private int level;
    private int population;
    private int maxPopulation;
    private int area;
    private int maxArea;
    private VillageHall villageHall;
    private List<Building> buildings;
    private List<Inhabitant> inhabitants;
    private ResourceManager resources;
    private int defenseScore;
    private int attackScore;
    private long guardPeriodEnd;
    private boolean inGuardPeriod;
    
    public Village(String name) {
        this.name = name;
        this.level = 1;
        this.population = 0;
        this.maxPopulation = 50;
        this.area = 0;
        this.maxArea = 100;
        this.buildings = new ArrayList<>();
        this.inhabitants = new ArrayList<>();
        this.resources = new ResourceManager();
        this.villageHall = new VillageHall();
        this.inGuardPeriod = true;
        this.guardPeriodEnd = System.currentTimeMillis() 
            + (7 * 24 * 60 * 60 * 1000);
    }
    
    public boolean addBuilding(Building b) {
        if (canBuild(b)) {
            buildings.add(b);
            return true;
        }
        return false;
    }
    
    public void removeBuilding(Building b) {
        buildings.remove(b);
    }
    
    public boolean addInhabitant(Inhabitant i) {
        if (population < maxPopulation) {
            inhabitants.add(i);
            population++;
            return true;
        }
        return false;
    }
    
    public int calculateDefenseScore() {
        defenseScore = 0;
        for (Building b : buildings) {
            defenseScore += b.getLevel() * 10;
        }
        return defenseScore;
    }
    
    public boolean canBuild(Building b) {
        return area + 10 <= maxArea;
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Core Package - Player Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package core;

import buildings.Building;
import inhabitants.Inhabitant;
import engine.AttackResult;

public class Player {
    private String playerName;
    private String playerId;
    private Village village;
    private int rank;
    private int attackWins;
    private int attackLosses;
    private int defenseWins;
    private int defenseLosses;
    private int totalLoot;
    
    public Player(String name) {
        this.playerName = name;
        this.playerId = generatePlayerId();
        this.village = new Village(name + "'s Village");
        this.rank = 0;
    }
    
    private String generatePlayerId() {
        return "P" + System.currentTimeMillis();
    }
    
    public boolean buildBuilding(Building b) {
        return village.addBuilding(b);
    }
    
    public boolean upgradeBuilding(Building b) {
        b.upgrade();
        return true;
    }
    
    public boolean upgradeInhabitant(Inhabitant i) {
        i.upgrade();
        return true;
    }
    
    public void updateRank() {
        rank = (attackWins * 10) - (attackLosses * 5) 
            + (defenseWins * 8) - (defenseLosses * 3);
    }
    
    public Village getVillage() {
        return village;
    }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{Engine Package - GameEngine Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package engine;

import java.util.List;
import java.util.ArrayList;
import core.Player;
import core.Village;
import buildings.Building;

public class GameEngine {
    private long currentTime;
    private double gameSpeed;
    private AttackSimulator attackSimulator;
    private VillageGenerator villageGenerator;
    private ScoreCalculator scoreCalculator;
    private List<Player> players;
    
    public GameEngine() {
        this.currentTime = System.currentTimeMillis();
        this.gameSpeed = 1.0;
        this.attackSimulator = new AttackSimulator();
        this.villageGenerator = new VillageGenerator();
        this.scoreCalculator = new ScoreCalculator();
        this.players = new ArrayList<>();
    }
    
    public void startGame() {
        currentTime = System.currentTimeMillis();
    }
    
    public void updateTime() {
        currentTime = System.currentTimeMillis();
    }
    
    public void processUpgrades(Village v) {
        // Process building and inhabitant upgrades
    }
    
    public boolean allowBuild(Village v, Building b) {
        return v.canBuild(b);
    }
    
    public void addPlayer(Player p) {
        players.add(p);
    }
}
\end{lstlisting}
\end{spacing}

\section{Engine Package - AttackResult Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package engine;

import resources.Cost;

public class AttackResult {
    private boolean success;
    private double successRate;
    private Cost loot;
    private int attackerLosses;
    private int defenderLosses;
    private int stars;
    
    public AttackResult(boolean success, Cost loot) {
        this.success = success;
        this.loot = loot;
        this.attackerLosses = 0;
        this.defenderLosses = 0;
        this.stars = success ? 3 : 0;
    }
    
    public boolean isSuccess() { return success; }
    public Cost getLoot() { return loot; }
    public int getStars() { return stars; }
}
\end{lstlisting}
\end{spacing}

\clearpage

\section{UI Package - GameUI Class}
\begin{spacing}{0.8}
\begin{lstlisting}[language=Java]
package ui;

import core.Player;
import engine.GameEngine;

public class GameUI {
    private Player currentPlayer;
    private GameEngine gameEngine;
    
    public GameUI(Player player, GameEngine engine) {
        this.currentPlayer = player;
        this.gameEngine = engine;
    }
    
    public void displayVillage() {
        System.out.println("=== Village ===");
        // Display village information
    }
    
    public void displayBuildMenu() {
        System.out.println("=== Build Menu ===");
        System.out.println("1. Farm");
        System.out.println("2. Gold Mine");
        System.out.println("3. Archer Tower");
    }
    
    public void displayAttackMenu() {
        System.out.println("=== Attack Menu ===");
        // Display attack options
    }
    
    public void handleUserInput() {
        // Handle user input for game actions
    }
}
\end{lstlisting}
\end{spacing}

\end{document}
